# Assignment 3

Maximum number of words for this document: 18000

**IMPORTANT**: In this assignment you will fully model and impement your system. The idea is that you improve your UML models and Java implementation by (i) applying (a subset of) the studied design patterns and (ii) adding any relevant implementation-specific details (e.g., classes with “technical purposes” which are not part of the domain of the system). The goal here is to improve the system in terms of maintainability, readability, evolvability, etc.    

**Format**: establish formatting conventions when describing your models in this document. For example, you style the name of each class in bold, whereas the attributes, operations, and associations as underlined text, objects are in italic, etc.

### Summary of changes of Assignment 2
Author(s): `name of the team member(s) responsible for this section`

Provide a bullet list summarizing all the changes you performed in Assignment 2 for addressing our feedback.

Maximum number of words for this section: 1000

### Application of design patterns
Author(s): Richard Eric van Leeuwen, Peter Wassenaar

`Figure representing the UML class diagram in which all the applied design patterns are highlighted graphically (for example with a red rectangle/circle with a reference to the ID of the applied design pattern`

For each application of any design pattern you have to provide a table conforming to the template below.

| ID  | DP1  |
|---|---|
| **Design pattern**  | Name of the applied pattern |
| **Problem**  | A paragraph describing the problem you want to solve |
| **Solution**  | A paragraph describing why with the application of the design pattern you solve the identified problem |
| **Intended use**  | A paragraph describing how you intend to use at run-time the objects involved in the applied design patterns (you can refer to small sequence diagrams here if you want to detail how the involved parties interact at run-time |
| **Constraints**  | Any additional constraints that the application of the design pattern is imposing, if any |
| **Additional remarks**  | Optional, only if needed |

| ID  | DP1  |
|---|---|
| **Design pattern**  | Factory method |
| **Problem**  | In our code we use multiple subclasses of the abstract class **item**. Depending on the situation we need different new *objects* of these subclasses, but using the *new* keyword would make our code hard to manage, extend and read. Also, the use of the *new* keyword is troublesome seen the type of *object* is decided during runtime using the provided jsons and thus cannot be hardcoded in. |
| **Solution**  | The application of the factory method allows us to separate the creation of new objects from the place where the objects are needed. The **ItemFactory class** this design pattern provides also makes it easier for use to add in any potential extra **item subclasses** and change how they are made. Most importantly, this method allows us to easily instantiate d*ifferent new objects* during runtime, which was an important issue to solve to make our system change depending on the jsons provided. |
| **Intended use**  | At the start of runtime, the program needs to use the provided json files to build the text adventure game. Most of this initialization happens in the **InitiationService** class. It will ask for new item objects by using the I**temFactory** class *GetItem()* method. The *getItem*() method accepts as parameter the String of the name of the item wanted. This name gets looked for in the json directories to connect it with the associated json file. Once the right json file is found using the item name, the json file gets used to create a *new item object* of the required **item subclass**. This **item subclass** gets returned to the caller from where it can use the item object in however way it deems fit. |
| **Constraints**  | The factory method requires that all **subclasses** have a common type to which it can be referred to. This common type is the **abstract class item**. This means that no matter the **subclass**, the object is treated as an *Item object*. This prevents the **subclasses** to have any additional functionality compared to the **item class**, they can only overwrite existing functionality. |
| **Additional remarks**  | Currently in our code there are two places from where the **itemfactory** gets called, the **InitiationService** and the **location** **class** *constructor*.|

Maximum number of words for this section: 2000

## Class diagram									
Author(s): `name of the team member(s) responsible for this section`

This chapter contains the specification of the UML class diagram of your system, together with a textual description of all its elements.

![Class Diagram](https://github.com/Areenor/SD/blob/Assignment-3/docs/Class_Diagram.png)

<p>To improve the readability of the class diagram, all getter and setter methods required and the associations connected to them are not included in the class diagram.</p>

<p>Location The Location class represents a room or area which contains objects and characters. Locations are linked together and can be accessed through different directions using the AdjacentLocations hashmap. Attributes: _name: The location&rsquo;s name. _baseDescription: Location&rsquo;s description, excluding the descriptions of items and NPCs in the location. _items: Items present in the location _NPCs: NPCs present in the location _adjacentLocations: The locations which are adjacent to the location. Operations: AddAdjacentLocation : adds a location reference to the adjacent location map. ContainsNpc : checks if the location contains an NPC. AddNpc : adds an NPC to the location. RemoveNPC : removes an NPC from the location. ContainsItem : checks if the location contains an item. AddItem : adds an item to the location. RemoveItem : removes an item from the location. GetNpcDescriptions : gets the descriptions of all NPCs in the location. GetItemDescriptions : gets the descriptions of all items in the location.</p>

<p>Character The Character class represents a person or other being which acts as a living entity in the game. Such living entities or beings would be, for example, a merchant, a bandit or a wolf. Note, the role a being plays in a story determines if it should be an instance of the Character or Item class; in one story a salamander may be regarded as a character which can be battled with or spoken to, while another story sees it as (functionally speaking) just an item that. Characters have a certain amount of hit points, representing their health, if these drop to zero the character will die. The amount of actions a character can perform in one turn during combat depends on their stamina, as long as this does not hit zero they can perform another action. Attributes: BASE_HEALTH : the base health of every character. BASE_ATTACK : the base attack of every character. BASE_STAMINA : the base stamina of every character. _name : name of the character. _strength : statistic influencing the character&rsquo;s _attack. _dexterity : statistic influencing the character&rsquo;s _maxStamina and chance to dodge chance during combat. _constitution : statistic influencing the character&rsquo;s _maxHitPoints, _block and standart damage mitigation during combat. _maxHitPoints : character&rsquo;s total health. _currentHitPoints : character&rsquo;s current health. _attack : damage a character can deal when attacking in combat. _block : amount of mitigated damage upon when blocking an attack in combat. _maxStamina : character&rsquo;s total stamina. _currentStamina : character&rsquo;s stamina. _inventory : the items in possession of the character.  Operations: ResetHealth : Restores _currentHitPoints to the value of _maxHitPoints. ResetStamina : Restores _currentStamina to the value of _maxStamina. AddToInventory : Adds an item to the character&rsquo;s inventory. RemoveFromInventory : Removes an item from the character&rsquo;s inventory Attack : Initiates combat with another character. Die : Triggers an event when the character is defeated in combat, this event is different for Player and NPC. DealDamage : character inflicts damage on another character.</p>

<p>Player Player inherits Character, and is controlled by the user. A player can equip an armor piece or weapon, boosting their stats (_strength, _dexterity, _constitution), however only one piece of equipment of each type may be equipped at once.  Attributes: _currentLocation: the location in which the player resides. _weapon : the equipment piece of type Weapon currently equipped by the player. _armor : the equipment piece of type Armor currently equipped by the player. _isDodge : boolean stating if the player is currently dodging, used during combat. _isBlock : boolean stating if the player is currently blocking, used during combat. Operations: EquipWeapon : equips a piece of equipment of type Weapon. EquipArmor : equips a piece of equipment of type Armor. Use : use an item in the player&rsquo;s inventory by itself. UseOnItem : use an item in the player&rsquo;s inventory on another item. UseOnNpc : use an item in the player&rsquo;s inventory on an NPC. TalkTo : initiate a conversation with an NPC. Take : remove an item from the current location and put it in the player&rsquo;s inventory. Move : move to a location adjacent to the current location, requires a direction to move in. Attak : triggers combat against an NPC and inflicts damage to it. Die : causes the player to respawn in the designated spawn room with full health and stamina. ResponseAction : executes a response action during combat if _currentStamina is greater than zero. PrintInventory : prints the names of all the items in the player&rsquo;s inventory. Respawn : sets the player&rsquo;s current location to the spawn location. Associations: Talk to : is triggered by the TalkTo function of Player and calls the Talk function of NPC. Move : is triggered by the Move function of Player, gets the location adjacent to the current location in the direction specified, this adjacent location then used to set the _currentLocation attribute of the player. Take : is triggered by the Take function of Player, removes an item from the player&rsquo;s current location and adds it to their inventory. Use : is triggered by the Use, UseOnItem, or UseOnNpc functions of Player and calls the Use function of NPC, the effect of Use in NPC will vary based on which Player function calls it and of which subclass the NPC instance is. An instance of Item or NPC can be passed when the player calls the Use operation of the target item. Equipped : an instance of Equipment may be equipped by a player. A player may have at most two pieces of equipment equipped at once, and a piece of equipment may be equipped to at most one player. Attack : may attack or be attacked by an NPC. A player is present in one location at a time, and can move between them.</p>

<p> NPC A subclass which inherits from the Character class. A character which is not controlled by the player. Attributes: _description : a description of the NPC. _type : the type of the NPC, such as wolf or vampire. _dialogue : the text spoken by the NPC when talking to them. _combatDialogue : the text spoken by the NPC when initiating combat with them. _isHostile : boolean stating if the NPC would attack a player on sight. _isFightable : boolean stating if the NPC can be attacked by the player. Operations: Talk : prints the content of the NPC&rsquo;s _dialogue attribute. Attack : triggers combat against a player and inflicts damage to them. PrintCondition : prints the condition the NPC is in based on _currentHitPoints. Die : removes the NPC from the location it&rsquo;s in and drops its inventory. DropInventroy : adds all the NPC&rsquo;s inventory items to the location it is present in. Associations: NPCs are present in one location at a time, and can move between them. Item An abstract class with multiple subclasses. The functionality of an item is mainly determined by the subclass type it&rsquo;s an instance of. The item subclasses are: Junk, KeyItem, Consumable, and Equipment. An Item is present in a location or a character&rsquo;s inventory, and can move between these. Attributes: _name : name of the item. _description : description of the item. _isRetrievable : boolean stating if an item can be picked up by a character (added to the character&rsquo;s inventory). _isWinningItem : boolean stating if picking up the item leads to victory / completing the game. _endText : text to be printed upon finishing the game; is null unless _isWinningItem is set to true. Operations: Use : triggers an event or action. An item may be used on its own, on an NPc or another item. The effect of Use depends on the Item instance&rsquo;s type. FinishGame : is called upon picking up an item which has _isWinningItem set to true; prints _endText , closes Terminal and ends the game. Associations: An item is either present in the inventory of a player or (exclusive) a location, and may be moved between these. Junk A subclass of Item with no additional effects. Inherits Item. Operations: Use : has no effect outside of printing some feedback for the player.</p>

<p>KeyItem A subclass of Item used to unlock a direction in a location, or to be traded with an NPC for another item. A key item can never be used on its own, but must be used on a specific item or NPC. Inherits Item. Attributes: _newTargetDescriptions : the new descriptions of the specific items the key item unlocks. A new description is set upon using the key item upon the corresponding item. _unlockDirections : directions which are unlocked when using the key item on specific target items. _unlockLocationNames : the names of the locations in which the key item can unlock a direction.  _npcItemExchange : contains the NPC which can trade the key item for another item and which items they trade it for. Operations: Use : if used on a correct target item a direction in a location will be unlocked, allowing a player to move in that direction. If used on a correct target NPC the key item is traded for another item. IsCorrectTargetItem : checks if the target item passed in Use is a correct target for the key item. IsCorrectTargetNpc : checks if the target NPC passed in Use is a correct target for the key item. SetTargetItemDescription : replaces the description of a target item with the corresponding description in _newTargetDescription if a key item is used on that item. GiveAccessNewLocation : adds the location name corresponding to the unlocked direction, found in _unlockedLocationNames, to the _adjacentLocation attribute of the player&rsquo;s current location.</p>

<p>Consumable A subclass of Item which can be used once to aid a player or harm an NPC. If the consumable is harmful it may only be used on an NPC and will lower one of their statistics, alternatively if a consumable is not harmful it may only be used on the player and will increase one of their statistics. Consumables can only be used once. Inherits Item. Attributes: _statChange : the amount by which the target statistic is changed upon use. _dangerous : boolean expressing if the consumable is harmful or not. _affectedStat : statistic to be effected upon use. Operations: Use : When used on its own and not harmful, a specified statistic of the player using it will be increased. When used on an NPC and harmful, a specified statistic of the NPC will be reduced. Both actions consume the consumable, removing it from the player&rsquo;s inventory.</p>

<p>Equipment A subclass of Item which can be equipped by a character, raising their statistics. Equipment has two distinct types, Weapon and Armor. Weapons tend to increase a character&rsquo;s _Stength and armor tends to increase _Constitution.  Attributes: _blockBonus : bonus to _constitution when equipped. _attackBonus : bonus to _strength when equipped. _type : type of the equipment, either Weapon or Armor. Operations: Use : when equipment is used on its own, it will be equipped by the player, if the player already wears a piece of equipment of the same type that piece of equipment will be unequipped in favor of the piece of equipment being used. Use will have no effect when a target is specified.</p>

<p>GameState Contains information about the state of the game, such as a reference to the user&rsquo;s character, whether the game is finished. Attributes: Combat : boolean stating if the game is in combat mode. IsFinished : boolean stating if the game is finished, becomes true once the player meets the victory condition. SpawnRoom : name of the location in which a new instance of Player is placed (the player&rsquo;s initial current location). MainCharacter : the user&rsquo;s character, an instance of Player. Locations : all locations used in the game. Operations: GetLocation : returns a specific location. Associations: GameState is a globally accessible class, and is referred to numerous times by different classes in the program, because of this most associations of GameState have been omitted from the class diagram, to improve clearness.</p>

<p>InitiationService A service used to initiate the instances of all non-abstract classes, except for the item subclasses, and reading the story specific json files. Attributes: storyDirPath : path to the directory of the story files. locationJsonDirPath : path to the directory containing the json files of the story&rsquo;s locations. npcJsonDirPath : path to the directory containing the json files of the story&rsquo;s NPCs. Operations: InitiateMainCharacter : creates an instance of Player which will be the user&rsquo;s character, and sets MainCharacter in GameState. InitiateCharacterInventory : creates an instance of an empty character inventory. InitiateLocations : creates a map of Location instances for every json file in the story&rsquo;s locations directory, and sets Locations in GameState.  InitiateLocation : creates an instance of Location. An instance of LocationConfig is used as an argument when initiating the location. InitiateNpc : creates an instance of NPC. An instance of NpcConfig is used as an argument when initiating the location. ReadLineByLine : reads the content of a json file into a string line by line. Associations: Initiates instances of Location, Player, and NPC. Also initiates the MainCharacter and Locations attributes of GameState. Passes new instances of NPC to an instance of Location.</p>

<p>ItemFactory A service which creates instances of the Item subclasses.  Attributes: storyDirPath : path to the directory of the story files. junkJsonDirPath : path to the directory containing the json files of the story&rsquo;s junk items. consumableJsonDirPath : path to the directory containing the json files of the story&rsquo;s consumable items. keyItemJsonDirPath : path to the directory containing the json files of the story&rsquo;s key items. equipmentJsonDirPath : path to the directory containing the json files of the story&rsquo;s equipment items. Operations: InitiateItem : creates an instance of an Item subclass. The instance of the subclass is created if a JSON file can be found matching the name passed when the function is called. An instance of ItemConfig, ConsumableConfig, KeyItemConfig, or EquipmentConfig is used for initiation depending on the item&rsquo;s type. IsExsitingFile : Checks if the passed path matches an existing JSON file. Associations: Initiates instances of Item subclasses. Passes new instances of Item to an instance of Location.</p>

<p>Controller A service which reads user input and executes user commands.  Operations: ExecuteCommand : retrieves user input, computes which command the user wishes to execute and executes it. ExecuteCombatCommand : retrieves user input while their character is in combat, computes which command the user wishes to execute and executes it. ExecuteResponseCommand : retrieves user input while they respond to a combat action of an enemy, computes which command the user wishes to execute and executes it. PrintCommands : prints the usable commands at the current moment. Examine : prints the description of the target (an Item or NPC) or the description of the player&rsquo;s current location if no target is specified. Talk : calls the player&rsquo;s Talk() operation. Take : calls the player&rsquo;s Take() operation. Move : calls the player&rsquo;s Move() operation. Use : calls the player&rsquo;s Use(), UseOnItem(), or UseOnNpc() operations, depending on the target specified by the user, if any. Attack : calls the player&rsquo;s Attack() operation. Associations: Perform action : makes an instance of Player perform an action such as take, move or use. Examine : retrieves the description of a location, item or NPC.</p>

<p>Combat Service which manages combat. Combat is performed between a player and one or multiple NPCs. NPCs are only able to attack the player, however the player can perform a multitude of actions. A player performs multiple actions each turn, depending on their stamina, they can attack, use a consumable, or dodge or block if their opponent attacks. To be able to dodge or block the player must have at least 1 stamina remaining once the NPC attacks them, meaning the user should properly manage the stamina of their character, this can be done by skipping a part of their turn. The stamina of a character gets regenerated completely at the start of their turn. If an NPC dies in combat, they will be removed from the location they&rsquo;re present in and will drop all the items in their inventory, a player on the other hand will simply respawn at the spawn location.  Attributes: combatOrder : keeps track of the turn order of all characters currently in combat. skipTurn : boolean stating if the player wants to skip their turn. Operations: Init : initiates combat; switches Combat in GameState to true, prints the combat dialogue of all enemies, adds all enemies and the player to _combatOrder, and sorts _combatOrder based on the characters&rsquo; dexterity and if the player attacks an NPC or the other way around. Run : runs combat and checks if all enemies are defeated. CombatEnd : ends combad; restores the player's health and stamina, clears combatOrder . and switches Combat in GameState to false. CombatFlow : loops over combatOrder and executes the combat action(s) for each character. RunNewOrder : called once an NPC dies, creates a new combat order without the killed NPC(s) and calls Run. PlayerAction : called on the player&rsquo;s turn. Executes the combat action the player makes by calling ExecuteCombatCommand in Controller as long as the player still has stamina. EnemyAction : makes an NPC attack the player. PrintCombatDialogues : gets and prints the _combatDialogue of each NPC in combat. Associations: InitiateCombat : when an NPC or player attacks the other they initiate combat. Perform combat action : Combat executes a player&rsquo;s combat action by calling ExecuteCombatCommand in Controller. Combat may make calls to Location, Player, NPC, or Character in order to update them, for example deleting an NPC from a location, or resetting a player&rsquo;s health and stamina.</p>

<p> Terminal A wrapper class for usage of the org.beryx.textio library; used for classes to print to and read from the terminal.</p>

<p>Attributes : INSTANCE : instance of the Terminal class. _textIO : instance of org.beryx.textio.TextIO, used to initiate _inputReader and _terminal. _inputReader : instance of org.beryx.textio.StringInputReader, used reading user input. _terminal : instance of org.beryx.textio.TextTerminal, used for printing to the terminal. Operations: Read : reads user input from the terminal. Print : prints a string to the terminal. PrintLine : prints a line to the terminal. CloseTerminal : desposes the _textIO instance. Associations Get user input : Terminal reads user input from the terminal and sends this in a string to the associated class. Print : Terminal prints the string passed by the associated class to the terminal, either as just a string or a line. This association is omitted from the class diagram to improve clearness, as the majority of the classes have this association. Configuration classes A total of six configuration classes are added to the project, and are used for the initiation of instances of Location, NPC, and all the Item subclasses. Using a JSON reader and deserializer, instances of these configuration classes are created from the story JSON files, such an instance can then be passed as an argument when calling the constructor of its corresponding class. Which configuration class is just to initiate which class is quite straight forward based on the name, except for the ItemConfig class which is used to initiate items of type Junk. Additionally the classes ConsumableCpnfig, KeyItemConfig and EquipmentConfig inherit the ItemConfig class. Taking the configuration classes contain the exact same attributes as the classes they correspond to, a detailed summary of their attributes will be left out.</p>

## Object diagrams								
Author(s): Leyla Celik

![Object Diagram](https://github.com/Areenor/SD/blob/Assignment-3/docs/Object_Diagram_2.0.png)

This diagram shows a snapshot of a player who had their **MainCharacter** enter a **Location** that contains **Equipment** and is adjacent to another **Location** with **Equipment** and a **Character**. The **MainCharacter** is an instance of the class Character with all inherited variables. The **MainCharacter** is named player1 and their stats are 5 *HitPoints*, 1 *Strength*, 1 *Dexterity* and 1 *Constitution* and 1 *Stamina*. The *MaxHitPoints* and *MaxStamin* are 10. The player can use items to increase *HitPoints* and *Stamina* for the **MainCharacter** with a cap of *MaxHitPoints* and *MaxStamina*. The **MainCharacter**’s inventory can consist of items such as **Equipment**, **Consumable**s, **KeyItem**s, etc. and, at this point in the snapshot, consists of a *torch*. The **MainCharacter** can use items such as **Equipment** with the command *‘Use’*. The **MainCharacter** is at a **Location** named *“a beach”*. The player gets a description of this **Location** upon entering it: “You are on a beach, there are objects and items. There is a room east.”. This **Location** contains two objects of subclass Equipment: one of type *'weapon'* that the **MainCharacter** can pick up (bool *IsRetrievable* = true;) named ‘Sword’ that gives an attack bonus of 1 (int *AttackBonus* = 1;) and one of type *'armor'* named ‘Chestplate’ that the **MainCharacter** can pick up (bool *IsRetrievable* = true;) that gives a block bonus of 1 (int BlockBonus = 1;); The **Location** *‘a beach’* has an adjacent location to the east (*AdjacentLocations* = {"east":"room"}) called *‘room’*. 
The adjacent location *‘room’* contains one item of subclass **Consumable** and an **NPC** of class **NPC**. The **Consumable** is a ‘Strength potion’ that the **MainCharacter** can pick up (bool *IsRetrievable* = true;) that is not dangerous (bool *IsDangerous* = false;), which means that the **MainCharacter** can use it on themselves. The affected stat is the *Strength* stat (*AffectedStat* = *Strength*;) and the added bonus is 1 (int *StatChange* = 1;). The potion has the description: “This potion will make you stronger on consumption.”. The **NPC** is named ‘Guard’, is of type *‘guard’*, has the description "This is a Guard that attacks on sight.", is hostile (bool *IsHostile* = true;) and is fightable (bool *IsFightable* = true;). Possible types of interactions with the **NPC** are: *‘Talk’*, which gives the player dialogue between the **MainCharacter** and the **NPC** and *’DropInventory’*, which adds all of the **NPC**’s items to the **Location** it is in. An **NPC** that *IsHostile* will attack the **MainCharacter** on sight, meaning the player will not have time to interact with the **NPC**.


## State machine diagrams									
Author(s): `name of the team member(s) responsible for this section`

This chapter contains the specification of at least 2 UML state machines of your system, together with a textual description of all their elements. Also, remember that classes the describe only data structures (e.g., Coordinate, Position) do not need to have an associated state machine since they can be seen as simple "data containers" without behaviour (they have only stateless objects).

For each state machine you have to provide:
- the name of the class for which you are representing the internal behavior;
- a figure representing the part of state machine;
- a textual description of all its states, transitions, activities, etc. in a narrative manner (you do not need to structure your description into tables in this case). We expect 3-4 lines of text for describing trivial or very simple state machines (e.g., those with one to three states), whereas you will provide longer descriptions (e.g., ~500 words) when describing more complex state machines.

The goal of your state machine diagrams is both descriptive and prescriptive, so put the needed level of detail here, finding the right trade-off between understandability of the models and their precision.

Maximum number of words for this section: 4000

## Sequence diagrams									
Author(s): Leyla Celik, Richard Eric van Leeuwen

This chapter contains the specification of at least 2 UML sequence diagrams of your system, together with a textual description of all its elements. Here you have to focus on specific situations you want to describe. For example, you can describe the interaction of player when performing a key part of the videogame, during a typical execution scenario, in a special case that may happen (e.g., an error situation), when finalizing a fantasy soccer game, etc.

For each sequence diagram you have to provide:
- a title representing the specific situation you want to describe;
- a figure representing the sequence diagram;
- a textual description of all its elements in a narrative manner (you do not need to structure your description into tables in this case). We expect a detailed description of all the interaction partners, their exchanged messages, and the fragments of interaction where they are involved. For each sequence diagram we expect a description of about 300-500 words.

The goal of your sequence diagrams is both descriptive and prescriptive, so put the needed level of detail here, finding the right trade-off between understandability of the models and their precision.


Now, we would like to discuss the movement scenario. 

![Sequence Diagram Movement](https://github.com/Areenor/SD/blob/Assignment-2/docs/Sequence_Diagram_Movement.png)

This movement sequence diagram shows the way the program handles a movement command when the direction the player wants to go to does not exist and when it does exist. The interaction partners in this diagram are the Player, **MainCharacter** and **Location**. We will discuss each of the interactions partners’ involvement and what their tasks are during this scenario. Player depicts an external influence and is the stakeholder of this diagram. The player is the person playing the game who inputs commands and controls the **MainCharacter**. The situation in this sequence diagram is as follows: the player wants to move the **MainCharacter** to a new **Location**. The player inputs a command to move the **MainCharacter** north of its current **Location**: “move north”. 
The **MainCharacter** processes the commands they receive from the player and will teleport if the direction the player wants to go in has a **Location**. The **MainCharacter** receives the “move north” command and will invoke the *move(“north”)* method to **Location**. 
**Location** is mostly a container for data, but also sends back a message depending on whether a **Location** exists in the direction chosen by the Player. If the direction chosen by the player has a **Location**, the message is a description of the **Location**. If there is no **Location** in that direction the message will say there was nothing in that direction. The player chose north as their direction to move in, but there is no *AdjacentLocation* north of the **MainCharacter**’s current **Location**, so Location sends the player the response “You found nothing traveling in this direction and returned to your original **Location**.” as output. The player tries to change locations again, this time wanting to move the **MainCharacter** east of its current **Location** with the command: “move east”. The **MainCharacter** receives the “move east” command and will invoke the *move(“east”)* method to **Location**. There is an adjacent **Location** east of the **MainCharacter**’s current **Location** and the player gets the response: "You are in a room, there are objects and items. There is a beach west." as output.

![Sequence Diagram Take](https://github.com/Areenor/SD/blob/Assignment-3/docs/Sequence_diagram_TakeCom.png)

In this sequence diagram we show the execution of the take command. The take command allows the user of the game, which we will refer to as the player actor, to remove an *item* from the *currentLocation* stored in the *player object* and put the *item* in the inventory of the *player object*. We decided to showcase this sequence seen it shows the execution of a typical command the player actor will regularly use and how the *player object* interacts with other *objects* to complete such a command.

First of all, the *Controller* requests the *Read()* function from the *Terminal*. The player actor inputs the command it wants, which in this case is "take potion", which gets forwarded as a reply back to the *Controller*. The *Controller* reads this command and calls his own *Take()* function where it checks for any command specific errors in the input it received from the *Terminal*. Upon not finding any, it calls the *Take()* function of the *player object* which has as parameter the name of the *Item* it wants taken. *The player object* receives this call and proceeds to process the execution of exchange of *Items*. First, it communicates with the *currentLocation object* it has stored inside himself and asks for the *item* wanted with as parameter the item name. In this case, the name is "potion" and it receives back the *potion Item object* which it stores in the variable targetItem. Now, it has the Item it wants stored in a variable, it proceeds to send another request to the *currentLocation object* telling it to remove the *potion item object* from the *currentLocation* with the function *RemoveItem()* which takes as parameter the name of the *item*. With the *item* removed from the *currentLocation*, the *player object* only needs to add it to his own *inventory* which it does with a call to himself called *AddToInventory()* with as parameter targetItem. The command is now completed, all that is left to do is tell the player actor it was successful. The *player object* sends to the *Terminal* using the *Terminal's PrintLine()* function the message containing the success of the action, in this case "You took the potion", which the *Terminal* then forwards to the player actor as output. The player actor now knows the command went successful and can now continue inputting a new command of his choosing.

## Implementation									
Author(s): `name of the team member(s) responsible for this section`

In this chapter you will describe the following aspects of your project:
- the strategy that you followed when moving from the UML models to the implementation code;
- the key solutions that you applied when implementing your system (for example, how you implemented the syntax highlighting feature of your code snippet manager, how you manage fantasy soccer matches, etc.);
- the location of the main Java class needed for executing your system in your source code;
- the location of the Jar file for directly executing your system;
- the 30-seconds video showing the execution of your system (you can embed the video directly in your md file on GitHub).

IMPORTANT: remember that your implementation must be consistent with your UML models. Also, your implementation must run without the need from any other external software or tool. Failing to meet this requirement means 0 points for the implementation part of your project.

Maximum number of words for this section: 2000
